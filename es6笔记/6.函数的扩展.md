#函数的扩展
## 1.函数参数的默认值
参数变量是默认声明的，所以不能使用let,const再次声明

使用参数默认值时。函数不能有同名参数

与解构赋值默认值结合使用

    function foo(x,y=5){
        consolog.log(x,y);
    }
    foo({}) //undefined 5
    foo({x:1})  //1 5

参数默认值的位置

通常情况下，定义了默认值的参数，应该是函数的尾参数

函数的length属性

指定了more之以后，函数的length属性，将返回没有制定默认值的参数个数，也就是说，制定了默认值后，length属性将失真

作用域

一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域，等到初始化结束，这个作用域就会消失，这种语法行为，在不设置参数默认值时，是不会出现的

## 2.rest参数

es6引入了rest参数，形式为...变量名。用于获取函数的多余参数，这样就不需要使用argumengts对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

## 3.严格模式

es6规定函数参数使用了默认值，结构复制，或者扩展运算符，那么函数内部就不能显示设定为严格模式，否则会报错
## 4.name属性

函数的name属性返回该函数的函数名

如果给匿名函数一个变量，es5的name属性，会返回空字符串，而es6会返回实际的函数名
## 5.箭头函数
es6允许使用箭头来定义函数

    var f=v=>v;
    //等同于
    var f=function (v){
        return v;
    }

如果不要参数或者需多个参数就使用一个圆括号代表参数部分

    var f=()=>5;
    //等同于
    var f=function(){return 5};

如果箭头函数的代码块部分多于一条语句面积要使用达阔韩将它们括起来，并且使用retur语句返回

    var sum=(num1,num2)=>{return num1+num2}

由于大括号会被解释为大妈快，若果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错

使用注意点

1.函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。

2.不可以当作狗函数，也就是说，不可以使用new命令，否则会抛出一个错误

3.不可以使用arguments对象，该对象在函数体内不存在，如果要用，可以使
用rest参数代替
    
4.不可以使用yield命令，因此箭头函数不能用作Generator函数

不适合场景

由于箭头函数使this从动态变为静态。以下两个场合不应该使用箭头函数。
第一个场合是定义函数的方法，且该方法内部包括this

    const cat={
        lives:9,
        jumos:()=>{
            this.lives--;
        }
    }

第二个场合是需要动态this的时候，也不应该使用箭头函数

    var button=document.getElementByID('aa');
    button.addEventListener('click',()=>{
        this.classList.toggle('on');
    })

 嵌套的箭头函数，

箭头函数内部，还可以使用箭头函数

## 6.双冒号运算符
：：用来替代call，apply,bind调用

    foo::bar;
    //等同于
    bar.bind(foo);

会自动将左边的对象，作文上下文环境（即this对象）,绑定到右边的函数上面

如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定早期该对象上面

如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法

##  7.尾调用优化
尾调用就是指某个函数的最后一步是调用另一个函数。

尾递归同理

## 8.函数参数的尾逗号


